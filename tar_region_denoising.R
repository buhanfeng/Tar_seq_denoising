
# dependencies
library(dplyr)
library(tidyverse)
library(sqldf)
library(Seurat)

#' initialize a tar object.
#' 
#' @param tar_gtf gtf file generated by tar-seq.
#' @param putative_gtf original gtf file.
#' @return a tar object.
#' 
#' @examples
#' tar_gtf = './tar.gtf'
#' putative_gtf = './putative.gtf'
#' tar_obj = initializing(tar_gtf, putative_gtf)
#' 
initializing = function(tar_gtf){
  tar_gtf = read.csv(tar_gtf, sep = '\t', header = F)
  tar_gtf = tar_gtf %>% group_by(V1, V4, V5) %>% slice(1)
  tar_gtf = as.data.frame(tar_gtf)
  dd = apply(tar_gtf, MARGIN=1, FUN=function(x){
    a = x[9]
    a = strsplit(a, split = '; ')
    a = unlist(a)
    b = a[1]
    b = gsub('gene_id ' ,'', b)
    b = strsplit(b, split = '_')
    b = unlist(b)
    o = NULL
    if(length(b) == 6){
      o = c(id=x[1], s=b[2], e=b[3], c=b[5], o='', t='None')
    }else if(length(b) == 8){
      o = c(id=x[1], s=b[2], e=b[3], c=b[5], o=b[6], t='Single')
    }else{
      n = paste(b[6:length(b)-1], collapse = ',')
      o = c(id=x[1], s=b[2], e=b[3], c=b[5], o=n, t='Multiple')
    }
    return(o) 
  })
  dd = t(dd)
  dd = as.data.frame(dd)
  dd[[2]] = as.numeric(dd[[2]])
  dd[[3]] = as.numeric(dd[[3]])
  dd[[4]] = as.numeric(dd[[4]])
  dd = cbind(dd, sub=dd[[3]] - dd[[2]])
  dd[[8]] = dd[[4]]/dd[[7]]
  colnames(dd) = c('ch', 'start', 'end', 'expression', 'pg_name', 'type', 'length', 'expression_nor')
  return(list(tar_gtf = tar_gtf, pre = dd, processing=dd))
}

#' withdraw filtering, note that only allow draw back one step.
#' 
#' @param tar_obj object generated by initializing function.
#' @return return revised tar_obj.
#' 
#' @examples
#' tar.redo(tar_obj)
#' 
tar.undo = function(tar_obj){
  tar_obj[['processing']] = tar_obj[['pre']]
  return(tar_obj)
}

#' summary the number of region categorized by type
#' summary the length and expression quartile
#' 
#' @param tar_obj object generated by initializing function.
#' @return no return.
#' 
#' @examples
#' regions_summary(tar_obj)
#' 
regions_summary = function(tar_obj){
  processing = tar_obj[['processing']]
  print('None overlap: ')
  print(str(nrow(processing[processing$type == 'None', ])))
  print('Single overlap: ')
  print(str(nrow(processing[processing$type == 'Single', ])))
  print('Multiple overlap: ')
  print(str(nrow(processing[processing$type == 'Multiple', ])))
  print('length quartile: ')
  print(summary(processing$length))
  print('expression quartile: ')
  print(summary(processing$expression))
}

#' discard overlap regions
#' 
#' @param tar_obj object generated by initializing function.
#' @return revised tar_obj.
#' 
#' @examples
#' discard_overlap_regions(tar_obj)
#' 
discard_overlap_regions = function(tar_obj){
  processing = tar_obj[['processing']]
  tar_obj[['pre']] = processing
  processing = processing[processing$type == 'None', ]
  tar_obj[['processing']] = processing
  return(tar_obj)
}

#' plot the length or expression (nor) distribution
#' 
#' @param tar_obj object generated by initializing function.
#' @param by a string indicate length/expression/expression_nor/sparsity.
#' @param highlight x-axis value of a highlighted point.
#' @return no return.
#' 
#' @examples
#' tar.dot_plot(tar_obj, by='length', highlight=50)
#' 
tar.dot_plot = function(tar_obj, by, highlight=NULL){
  if(by == 'sparsity'){
    d = tar_obj[['sparsity_stat']]
    plot(d$sparsity, d$count, pch=19)
  }else{
    processing = tar_obj[['processing']]
    y = sort(processing[[by]], decreasing = T)
    x = 1: length(y)
    plot(x, y, pch=19)
  }
  if(!is.null(highlight)){
    points(highlight[1], highlight[2], col='red')
  }
}

#' this function use to calculate accumulation of a curve.
#' 
#' @param tar_obj object generated by initializing function.
#' @param by a string indicate length/expression/expression_nor.
#' @param X percentage, a integer range from 0-100.
#' @param start_from calculate accumulation start from a offset inference from
#'  'by' parameter.
#' @return value which hit X.
#' 
#' @examples
#' tar.dot_plot(tar_obj, by='length', highlight=50)
#' 
accumulateX = function(tar_obj, by, X = 5, start_from=NULL){
  processing = tar_obj[['processing']]
  y = sort(processing[[by]], decreasing = T)
  if(!is.null(start_from)){
    y = y[y<=start_from]
  }
  ac = accumulate(y, function(a,b){a+b})
  ac = ac/ac[length(ac)]
  ac = ac[ac<=X/100]
  thre = c(length(ac), y[length(ac)])
  return(thre)
}

#' this function use to find elbow position from the curve base on orthology
#' distance to the line which determined by two apex.
#' 
#' @param tar_obj object generated by initializing function.
#' @param by a string indicate length/expression/expression_nor.
#' @return value which hit X.
#' 
#' @examples
#' find_elbow(tar_obj, by='expression_nor')
#' 
find_elbow = function(tar_obj, by){
  y = NULL
  x = NULL
  if(by == 'sparsity'){
    sparsity_stat = tar_obj[['sparsity_stat']]
    y = sparsity_stat$count
    x = sparsity_stat$sparsity
  }else{
    processing = tar_obj[['processing']]
    y = sort(processing[[by]], decreasing = T)
    x = 1:length(y)
  }
  b = c(x[1], y[1])
  c = c(x[length(x)], y[length(y)])
  v1 = b - c
  d = 0
  thre = 0
  for(i in 2:length(y)-1){
    a = c(x[i], y[i])
    v2 = a - b
    m = cbind(v1,v2)
    temp = abs(det(m))/sqrt(sum(v1*v1))
    if(temp>=d){
      d = temp
      thre = c(x[i], y[i])
    }
  }
  return(thre)
}

#' this function use to do filter, which can't be undone. 
#' 
#' @param tar_obj object generated by initializing function.
#' @param by a string indicate length/expression/expression_nor.
#' @param head threshold where the head will be cut to.
#' @param tail threshold where the tail will be cut from.
#' @return revised tar_obj.
#' 
#' @examples
#' tar.cut(tar_obj, by='length', head=60000)
#' 
tar.cut = function(tar_obj, by, head = NULL, tail = NULL){
  processing = tar_obj[['processing']]
  tar_obj[['pre']] = processing
  if(!is.null(head)){
    processing = processing[processing[[by]]<=head, ]
  }
  if(!is.null(tail)){
    processing = processing[processing[[by]]>=tail, ]
  }
  tar_obj[['processing']] = processing
  return(tar_obj)
}

#' this function generate a file which further used for
#'  extracting reads and blast.
#' 
#' @param tar_obj object generated by initializing function.
#' @param file position to persist the file.
#' @return revised tar object.
#' 
#' @examples
#' to_blast(tar_obj, file = './toblast.txt')
#' 
to_blast = function(tar_obj, file = './toblast.txt'){
  processing = tar_obj[['processing']]
  tar_toblast = cbind(processing[[1]], 
                      paste0(processing[[2]], '-', processing[[3]]))
  write.table(tar_toblast, file = file, 
              row.names = F, 
              col.names = F, 
              quote = F, 
              sep = ':')
}

#' this function append blast result to tar object.
#' 
#' @param tar_obj object generated by initializing function.
#' @param file point to blast result file.
#' @return revised tar obj.
#' 
#' @examples
#' read_blast(tar_obj, file = './blast.tsv')
#'
read_blast = function(tar_obj, file = './blast.tsv'){
  blast = read.csv(file, sep = '\t', header = F)
  tar_obj[['blast']] = blast
  return(tar_obj)
}

#' this function check which record yield blast result.
#' 
#' @param tar_obj object generated by initializing function.
#' @return revised tar obj.
#' 
#' @examples
#' check_blast(tar_obj)
#'
check_blast = function(tar_obj){
  blast = tar_obj[['blast']]
  blast = blast %>% group_by(V1) %>% slice(1)
  temp = gsub("[:\\-]", "_", blast$V1)
  tar_obj[['index_blast']] = temp
  return(tar_obj)
}

#' this function remove index without annotation result (blast result).
#' note that this can't be undone, please check 'index_blast' before calling.
#' 
#' @param tar_obj object generated by initializing function.
#' @return revised tar obj.
#' 
#' @examples
#' filter_by_blast(tar_obj)
#'
filter_by_blast = function(tar_obj){
  processing = tar_obj[['processing']]
  tar_obj[['pre']] = processing
  processing = as.data.frame(processing)
  rownames(processing) = 
    paste(processing$ch, processing$start, processing$end, sep = '_')
  processing = processing[tar_obj[['index_blast']], ]
  tar_obj[['processing']] = processing
  return(tar_obj)
}

#' this function persist denoised tar gtf.
#' 
#' @param tar_obj object generated by initializing function.
#' @return revised tar obj.
#' 
#' @examples
#' generate_tar_denoised_gtf(tar_obj, file = './tar_denoised.gtf')
#'
generate_tar_denoised_gtf = function(tar_obj, file = './tar_denoised.gtf'){
  tar_gtf = tar_obj[['tar_gtf']]
  rownames(tar_gtf) = 
    paste(tar_gtf$V1, tar_gtf$V4, tar_gtf$V5, sep = '_')
  processing = tar_obj[['processing']]
  index = paste(processing$ch, processing$start, processing$end, sep='_')
  temp = tar_gtf[index,]
  temp = sqldf("select * from temp order by V1,V4")
  write.table(temp, 
              file = file, 
              row.names = F, 
              col.names = F, 
              quote = F, 
              sep = '\t')
  tar_obj[['tar_denoised_gtf']] = temp
  return(tar_obj)
}

#' this function persist merging gtf (denoised tar gtf + putative gtf).
#' 
#' @param tar_obj object generated by initializing function.
#' @return no return.
#' 
#' @examples
#' generate_merge_gtf(tar_obj, file = './tar_and_putative.gtf')
#'
generate_merge_gtf = 
  function(tar_obj, file = './tar_and_putative.gtf', putative_gtf = './putative.gtf'){
  tar_denoised_gtf = tar_obj[['tar_denoised_gtf']]
  putative_gtf = read.csv(putative_gtf, sep = '\t', header = F)
  merging = rbind(putative_gtf, tar_denoised_gtf)
  merging = sqldf("select * from merging order by V1,V4")
  write.table(merging, 
              file = file, 
              row.names = F, 
              col.names = F, 
              quote = F, 
              sep = '\t')
}

#' this function read 10x expression matrix to tar object.
#' 
#' @param tar_obj object generated by initializing function.
#' @param path point to 10x expression matrix path
#' @return revised tar_obj.
#' 
#' @examples
#' tar_obj = tar.read_10x(tar_obj, path = './filtered_feature_bc_matrix')
tar.read_10x = function(tar_obj, path){
  dd = Read10X(data.dir = path)
  tar_obj[['exp_mat']] = dd
  return(tar_obj)
}

#' this function parse sparsity from expression matrix.
#' 
#' @param tar_obj object generated by initializing function.
#' @return revised tar_obj.
#' 
#' @examples
#' tar_obj = parse_sparsity(tar_obj)
parse_sparsity = function(tar_obj){
  exp_mat = as.matrix(tar_obj[['exp_mat']])
  dd = apply(exp_mat, MARGIN=1, FUN=function(x){
    c = length(x[x!=0])
    return(c) 
  })
  dd = data.frame(id=names(dd), sparsity=dd)
  dd = apply(dd, MARGIN=1, FUN=function(x){
    id = x[1]
    id = strsplit(id, split = '_')
    id = unlist(id)
    id = paste(id[1:3], collapse = '_')
    return(c(id=id, x[2])) 
  })
  dd = as.data.frame(t(dd))
  dd$sparsity = as.numeric(dd$sparsity)
  processing = tar_obj[['processing']]
  processing$id = paste(processing$ch, processing$start, processing$end, sep = '_')
  processing = inner_join(processing, dd, by='id')
  processing = processing[,c(1:8,10)]
  tar_obj[['processing']] = processing
  y = processing %>%
    group_by(sparsity) %>%
    summarize(count = n())
  y = arrange(y, sparsity)
  tar_obj[['sparsity_stat']] = y
  return(tar_obj)
}




















